'''
something I updated in Q2:
class Classifier
1. Add two parameters in constructor, which is about the positive and negative file path and give them default path, so that when we reuse it, we don't need to change the code.
2. Modularize the code for processing text to words as private function _processText, so it can be used by other method.
2. Add function sentimentFreqRatio: Given the text and specific type of sentiment, it can calculate the frequency ratio in the text.
3. Add function getSentimentWords: Given the text and specific type of sentime, it can return the sentiment words and its frequency number in descending order, the format like this list[(word, freqencyNumber)]
'''


class SentimentLexicon:
    """It mantains the instance variable, scoreMap, which store the sentiment scores of words"""

    def __init__(self):
        self.scoreMap = {}  # store the word and its sentiment score

    def load(self, positivePath, negativePath):
        """Reading positive words and negative words file, and store each word sentiment score.

        Args:
            positivePath (str): The path to the file storing positive words.
            negativePath (str): The path to the file storing negative words.
        """
        # Open file and read each line.
        positiveFile = open(positivePath, 'r')
        negativeFile = open(negativePath, 'r')
        positiveLines = positiveFile.readlines()
        negativeLines = negativeFile.readlines()
        positiveFile.close()
        negativeFile.close()

        # Loop lines and store the sentiment score of word.
        self._addScore(positiveLines, 1)
        self._addScore(negativeLines, -1)

    def _addScore(self, lines, score):
        """It is a process that store the score to instance variabale scoreMap in the end.

        Args:
            lines (list[str]): String list generated by file.readlines().
            score (int): The sentiment score which this type of words own (1:positive, -1:negative).
        """
        for word in lines:
            if word[0] == ';' or word == '':  # pass the comment and blank
                pass
            else:
                word = word[0:-1]  # remove the \n symbol
                self.scoreMap[word] = score

    def getScoreMap(self):
        """expose instance variable scoreMap"""
        return self.scoreMap


class Classifier:
    """The class maintain the SentimentLexicon object, and have a classify method to judge sentiment of the given sentence."""

    def __init__(self, positivePath='positive-words.txt', negativePath='negative-words.txt'):
        sentimentLexicon = SentimentLexicon()   # Create SentimentLexicon object
        # Load the file, to get dictionary of sentiment.
        sentimentLexicon.load(positivePath, negativePath)
        # Store this object to instance variable of classifier
        self.sentimentLexicon = sentimentLexicon

    def classify(self, text):
        """Measure text's sentiment score.

        Args:
            text (str): The text which need to judge sentiment.

        Returns:
            [int]: The sentiment score.
        """
        words = self._processText(text)
        sumScore = 0  # initial the sum of score
        scoreMap = self.sentimentLexicon.getScoreMap()
        for w in words:
            if w in scoreMap:  # if the word in the scoreMap, then add the score
                sumScore += scoreMap[w]
        return sumScore

    def _processText(self, text):
        """preprocess text to words

        Args:
            text (str): the text

        Returns:
            list[str]: change the text to string
        """
        cleanText = text.lower()  # change sentence into lowercase
        words = cleanText.split()  # split words
        return words

    def sentimentFreqRatio(self, text, sentimentType='all'):
        """given the text and the sentiment type, return the specific sentiment words frequency ratio

        Args:
            text (str): the text
            sentimentType (str, optional): type of sentiment, the values have 'positive', 'negative' and 'all'. Defaults to 'all'.

        Returns:
            float: the sentiment words frequency ratio
        """
        words = self._processText(text)
        sentimentsNum = 0
        if sentimentType not in ['positive', 'negative', 'all']:
            raise ValueError('sentimentType is wrong')
        for word in words:
            if self._meetsentimentType(word, sentimentType):
                sentimentsNum += 1
        return round(sentimentsNum/len(words), 2)

    def _meetsentimentType(self, word, type):
        """private method, to meed the type condition

        Args:
            word (str)
            type (str): values are 'positive', 'negative' and 'all'

        Returns:
            Boolean: wether the word is the specified sentiment type
        """
        if word in self.sentimentLexicon.scoreMap:
            if (type == 'all')\
                    or (type == 'positive' and self.sentimentLexicon.scoreMap[word] == 1)\
                    or type == 'negative' and self.sentimentLexicon.scoreMap[word] == -1:
                return True
            else:
                return False
        else:
            return False

    def getSentimentWords(self, text, type='all'):
        """given the text and the sentiment type, return the specific sentiment words.

        Args:
            text (str)
            type (str): values are 'positive', 'negative' and 'all'
        Returns:
            [type]: [description]
        """
        words = self._processText(text)
        sentimentWords = []
        freq = {}
        for word in words:
            if word in freq:
                freq[word] += 1
            else:
                freq[word] = 1

        sortedFreqs = list(freq.items())
        sortedFreqs.sort(
            key=lambda item: item[1], reverse=True)

        for item in sortedFreqs:
            if self._meetsentimentType(item[0], type):
                sentimentWords.append(item)

        return sentimentWords


def main():
    """text above class"""
    classifier = Classifier()
    sentences = [  # text sentences
        'I love Python.',
        'Python is the language I love!',
        'The iPhone is clearly not the most terrible and worst phone ever. It is the best.',
        "I hate you.",
        "It is a great day, but I am unhappy, my heart was broken"
    ]
    results = []

    def textSentences(sentimentType='all'):
        for sentence in sentences:
            score = classifier.classify(sentence)  # give the score
            # give the sentiment frequent ratio
            ratio = classifier.sentimentFreqRatio(sentence, sentimentType)
            sentimentWords = classifier.getSentimentWords(
                sentence, sentimentType)  # give sentiment words
            result = {'text': sentence, 'sentiment': score, 'ratio': ratio,
                      'sentimentWords': sentimentWords}  # generate result
            print(result)
            results.append(result)  # append the result

    print('sentiment type: all')
    textSentences()
    print()
    print('sentiment type: positive')
    textSentences('positive')
    print()
    print('sentiment type: negative')
    textSentences('negative')


if __name__ == "__main__":
    main()
